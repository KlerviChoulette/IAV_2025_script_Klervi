---
title: "Script_IAV_2025"
author: "Klervi Choulette"
date: "2025-09-22"
output:
  pdf_document: default
  html_document: default
---


Ce script permet de faire tourner le calcul de l'Indice Avifaune Vivante (IAV) depuis un jeu de données.


Remplacer par le chemin d'accès du jeu de données.  

```{r}
path_data = "C:/Users/choul/Desktop/Work/Master/MODE_Rennes/M2/Stage/Stage_IAV/Stage_IAV/Table_reference_IAV_BFC_vall.csv"
```


Chargement des packages utilisés :  

```{r}
library(ggplot2)
library(dplyr)
library(tidyverse)
library(outliers)
library(purrr)
library(RColorBrewer)
library(gridExtra)
library(rlpi)
library(tibble)
library(patchwork)
library(mgcv)
library(gratia)
library(ggh4x)
```



Importation des fonctions :  

```{r}
source("Fonction_IAV.R")
```



```{r}
#### Création des palettes de couleur : 
color_dept = c("#F0BA8E",
               "#E88E00",
               "#E760A4",
               "#C70039",
               "#7A1A48",
               "#002E8A",
               "#4472C4",
               "#A6A9D6") 

color_domaine = c("agricole" = "#E88E00",
                  "aquatique" = "#4472F4",
                  "forestier" = "#31a354",
                  "maritime" = "#002E8A",
                  "rocheux/bati" = "#543005",
                  "NA" = "grey",
                  "global" = "black")

color_migration = c("partiel" = "#C70039",
                    "sedentaire" = "#4472C4",
                    "trans-saharien" = "#E88E00")

color_cavicole= c("non" = "#C70039",
                  "oui" = "#4472C4",
                  "semi" = "#E88E00")

color_hauteur_nidif= c("haut" = "#C70039",
                       "sol" = "#4472C4",
                       "bas" = "#E88E00",
                       "inclassable" = "grey50")

color_colonial= c("non" = "#4472C4",
                  "oui" = "#E88E00")

color_gene= c("gene" = "#4472C4",
              "spe" = "#E88E00")

color_lpo = c("#F55F19","#0087CD")

color_affinite.thermique= c("meridionale" = "#4472C4",
                            "septentrionale" = "#E88E00")

color_gpe <- c(
  "1. milieux ruraux heterogenes" = "#C2A83E",  # Jaune terreux (agriculture, champs)
  "2. landes, fourres, coupes" = "#8B4513",  # Marron foncé (végétation basse, sols secs)
  "3. vieilles forets de plaine" = "#228B22",  # Vert forêt dense
  "4. forets de montagne" = "#2E8B57",  # Vert sapin (forêts d'altitude)
  "5. maquis, garrigues" = "#A0522D",  # Brun rougeâtre (végétation méditerranéenne)
  "6. steppes, openfields" = "#E1AC69",  # Brun clair chaud (prairies arides)
  "7. prairies humides" = "#32CD32",  # Vert clair (prairies luxuriantes)
  "8. cotes sableuses" = "#FFD700",  # Jaune sable (plages)
  "9. villes, villages" = "#D2691E",  # Brun orangé (toits en tuiles, matériaux urbains)
  "10. cotes rocheuses" = "#8B0000",  # Rouge brique (falaises minérales)
  "11. roselieres" = "#9ACD32",  # Vert olive (zones humides, roseaux)
  "12. marais" = "#556B2F",  # Vert kaki (zones marécageuses)
  "13. plans d'eau" = "#4682B4",  # Bleu acier (lacs, étangs)
  "14. rivieres a lit mobile" = "#00BFFF",  # Bleu clair (cours d’eau dynamiques)
  "15. ripisylves" = "#006400",  # Vert foncé (forêts riveraines)
  "16. torrents" = "#1E90FF",  # Bleu intense (eaux vives, torrents)
  "17. rochers, falaises" = "#B22222",  # Rouge foncé (minéral, roches)
  "NA" = "grey",  # Valeurs manquantes (garde le gris ici)
  "global" = "black"  # Catégorie globale
)
```




#### *1 - PREPARATION DES DONNEES* 


LE JEU DE DONNEES NE DOIT PAS AVOIR DE ";" MERCI

##### *1) Importation du jeu de données*   

Déterminer le type d'encodage du fichier pour pouvoir gérer les caracteres speciaux
```{r}
guess_encoding(path_data)
```

Importer les données avec le bon encodage (important pour les accents)
```{r}
data_all = read.csv(path_data, header = T, dec = ",", 
                    sep = ";", stringsAsFactors = T,
                    fileEncoding="ISO-8859-1")
```

##### *2) Mise en forme des données*  

Regarder d'abord le summary pour voir d'éventuels problèmes (les accents, les majuscules, les valeurs vides etc.).  

```{r}
summary(data_all)
```


Enlever les caractères problématiques.  

```{r}
### Enlever les accents des colonnes :  

# Enlever les caratères speciaux et les majuscules des noms des colonnes
colnames(data_all) = tolower(iconv(colnames(data_all), to = "ASCII//TRANSLIT"))

# Pour les colonnes qui sont des facteurs, convertir en sans accent
for (C in colnames(data_all)){
  if (is.factor(data_all[,C]) == TRUE){
    data_all[,C] = as.factor(iconv(data_all[,C], to = "ASCII//TRANSLIT"))
    data_all[,C] = as.factor(tolower(data_all[,C]))
  }
}


### Enlever les eventuel espaces en trop dans la colonne binomial

data_all$binomial = gsub(" ", "", data_all$binomial)

### Remplacer les valeurs "vides" par des NA

data_all = data_all %>%
  mutate(across(everything(), ~ case_when(
    . == "" ~ NA,  # Remplace les chaînes vides par NA
    TRUE ~ .  # Laisse les autres valeurs inchangées
  )))
```


Vérifier la présence de NA. Les colonnes binomial, popvalue, id et year ne doivent pas présenter de données manquantes.  

```{r}
colSums(is.na(data_all))
names(which(colSums(is.na(data_all %>% select(binomial, popvalue, id, year))) != 0))
```

Les données sont prêtes à être traitées.

Séparation en deux jeu de données : hivernants et nicheurs.

```{r}
data_all_nicheur = data_all %>%filter(saisonnalite == "nicheur")
data_all_hivernant = data_all %>%filter(saisonnalite == "hiver")
```

Dans cette première partie, seul les espèces nicheuses de la région BFC seront étudiées.

##### *3) Sélection des données selon des critères choisis*  

Au préalable : 
- Retrait des mesures de l'année 2020 pour le dispositif STOC pour les déparements 25,39,70,90. 
- Vérifier que les zéros présents dans les séries sont des "vrais" zéros. Pas plusieurs zéros d'affiler au début ou fin de série sinon le calcul considère qu'une population nulle est une population stable avec un taux de croissance de 1 ce qui biaisera la moyenne des taux de croissances. 

------------------------------------------------------------------A FAIRE 


```{r}
data_all_nicheur = data_all_nicheur %>%
  filter(!(dept %in% c(25,39,70,90) & dispositif == "stoc" & year == 2020))
```


Critères : 
- Durée de la série : au moins 10 années de suivis (entre la première et la dernière mesure) ;  
- Nombre de mesure dans une série : au moins 3 mesures par séries ; 
- L'abondance maximum au cours de la série : doit être supérieur à 5 ;  
- Retrait du STOC non significatif


Créer un tableau pour caractériser chaque série : 

```{r}
# Resumer des caracteristiques des series temporelles
resume_serie_all_nicheur = data_all_nicheur %>%
  group_by(binomial, dept, id) %>%
  summarise(
    max_popvalue = max(popvalue),
    nb_mesures = n(),  # Nombre total de mesures
    nb_zeros = sum(popvalue == 0),  # Nombre de zéros
    debut = min(year),  # Année de la première mesure
    fin = max(year),  # Année de la dernière mesure
    duree = fin - debut + 1,  # Durée totale en années (+1 pour compter année de début)
  ) %>%
  ungroup()%>%
  left_join(data_all_nicheur%>%
              distinct(id, stoc.significativite))

# Ajout du nombre de départements par espèce
resume_serie_all_nicheur = resume_serie_all_nicheur %>%
  left_join(data_all %>%
              group_by(binomial) %>%
              summarise(nb_series_esp = n_distinct(dept)),
            by = "binomial")

# Ajout d'un indicateur de régularité des séries
resume_serie_all_nicheur = resume_serie_all_nicheur %>%
  group_by(binomial) %>%
  mutate(
    all_dept = nb_series_esp == 8
  )

# Affichage du résumé final
resume_serie_all_nicheur
```

Liste des séries retirer d'après les critères :  

Pour chaque série une évaluation des critères est réalisée : oui = la série remplie le critère, non = la série doit être retirée du jeu de données. La colonne *sélection* permet de savoir si oui la série est sélectionnée pour les analyses ou non elle est retirée. La colonne *critere* permet de savoir pour quelle raison cette série est retirée (il peut en avoir plusieurs).
```{r}
resume_serie_all_nicheur = resume_serie_all_nicheur %>%
  mutate(
    critere_nb_mesures = ifelse(nb_mesures < 3, "non", "oui"),
    critere_duree= ifelse(duree < 10, "non", "oui"),
    critere_max_popvalue= ifelse(max_popvalue < 6, "non", "oui"),
    critere_stoc = case_when(
      stoc.significativite == "non" ~ "non",
      TRUE ~ "oui"
    ),
    critere = paste0(
      ifelse(critere_nb_mesures == "non",  "nb_mesures ",""),
      ifelse(critere_duree == "non", "duree ", ""),
      ifelse(critere_max_popvalue == "non",  "max_popvalue ", ""),
      critere_stoc = case_when(
        stoc.significativite == "non" ~ "non_significatif",
        TRUE ~ ""
      ))%>% trimws(),
    
    # Selection : "oui" si aucune condition bloquante
    selection = ifelse(critere == "", "oui", "non"),
    critere = ifelse(critere == "", NA, critere)
  )
```

Liste des séries sélectionnées selon les critères et liste des séries retirées.
```{r}
# Liste pour selection == "oui"
liste_oui <- resume_serie_all_nicheur %>%
  filter(selection == "oui") %>%
  group_by(binomial) %>%
  summarise(
    dept_list = paste(unique(dept), collapse = ", "),
    nb_dept = n_distinct(dept)
  ) %>%
  mutate(output = paste0(binomial, " : ", dept_list))

# Liste pour selection == "non"
liste_non <- resume_serie_all_nicheur %>%
  filter(selection == "non") %>%
  group_by(binomial) %>%
  summarise(dept_list = paste(unique(dept), collapse = ", ")) %>%
  mutate(output = paste0(binomial, " : ", dept_list))

# Affichage
cat("✅ Série sélectionnée:\n", paste(liste_oui$output, collapse = "\n"), "\n\n")
cat("❌ Série non sélectionnée:\n", paste(liste_non$output, collapse = "\n"))
```

Parmi les séries sélectionnées certaines ne couvre pas l'ensemble des 8 départements pour une espèce donnée. Il est important de vérifier que les séries représentent bien les populations de la région pour chaque espèce.

Liste des espèces présentant moins de 8 séries :


```{r}
cat("==> Espèce avec moins de 8 séries:\n", paste(liste_oui%>%filter(nb_dept<8)%>%pull(output), collapse = "\n"), "\n\n")
```
Sur ces 41 espèces, 5 ont été retirées car les séries ne représentaient pas bien l'ensemble des populations sur la région.
Liste des espèces retirées : 

```{r}
list_esp_retiree = c("blongios_nain",
                     "busard_saint_martin",
                     "cigogne_noire",
                     "corbeau_freux",
                     "roselin_cramoisi")
print(list_esp_retiree)
```

Seul les séries sélectionnées seront utilisées dans l'analyse de l'IAV. 

Création du data_nicheur_clean. 

```{r}
pop_garder_clean = resume_serie_all_nicheur%>%
  filter(critere_nb_mesures == "oui" & 
           critere_duree == "oui" &
           critere_stoc == "oui" &
           critere_max_popvalue == "oui" & !(binomial %in% list_esp_retiree)
  )%>%
  distinct(id)%>%pull(id)

data_nicheur_clean = data_all_nicheur%>%
  filter(id %in% pop_garder_clean)

cat("==> Nombre d'espèces:", n_distinct(data_nicheur_clean$binomial), "\n\n")
cat("==> Nombre de populations:", n_distinct(data_nicheur_clean$id))

```

Il est a présent possible de calculer l'IAV. Plusieurs méthodes : utiliser la fonction du WWF mais pas accès à toutes les données + création d'un nouveau jeu de données pour le calcul de chaque sous-indicateurs ; utiliser ses propres fonctions. 


#### *3 - Calcul de l'IAV global*


##### *1) Définition des variables :*   



```{r}
#Données
  Species = data_nicheur_clean["binomial"]
  ID = data_nicheur_clean["id"]
  Year = data_nicheur_clean["year"]
  Popvalue = data_nicheur_clean["popvalue"]
  
  
  #Paramètrage
  REF_YEAR = 2002
  LINEAR_MODEL_FLAG = TRUE
  CHAIN_MODEL_FLAG = TRUE
  MethodFlagLoop = 0
  LAMBDA_MAX = 1
  LAMBDA_MIN = -1
  CAP_LAMBDAS = TRUE
  
  
  
  
  FinalYear = max(Year)
  InitialYear = min(Year)
  NumberYear = FinalYear - InitialYear +1
  
  
  noRecs = max(dim(Popvalue))
  sNames = unique(pull(Species))
  sID = unique(ID)
  noSpecies = max(dim(unique(Species)))
  noPop = max(dim(unique(ID)))
  MethodFlag = matrix(0, 1, noPop)
  
  sNamesCounter = 0
  sNamesArray = sNames
  sIDArray = sID
  
  asso_SPNames_Number = data.frame(
    binomial = sNames,
    number = seq_along(sNames),
    stringsAsFactors = FALSE
  )
  
  
  PopProcessedGAM = matrix(0, 1, noPop)
  
  #Tableau pour récupérer les données
  data_SpeciesLambda_2002 = matrix(0, noSpecies, FinalYear - REF_YEAR + 
                                1)
  SpeciesLambda = matrix(0, noSpecies, FinalYear - REF_YEAR + 
                           1)
  PopPredict = as.data.frame(matrix(ncol = 5+NumberYear+NumberYear)) #Sur 35ans (x2 pour les SE) ET 5 col pour infos suplémentaires
  colnames(PopPredict) = c("binomial", "id", "Model", "Model_valide", "Smooth_para", 
                           seq(InitialYear,FinalYear, by = 1), paste(seq(InitialYear,FinalYear, by = 1), "_se", sep = ""))
  
  #variable pour récupérer des infos
  nb_pop_year_lambda = rep(0, NumberYear)
  nb_sp_year_dtemp = rep(0,  FinalYear - REF_YEAR +1)
  compteur = 0
  model_used = c()
  model_valid_used = c()
  
  
  cat(sprintf("Number of species: %s (in %s populations)\n", 
              noSpecies, noPop))
```

##### *2) GAM et Lambda par espèces :*  


Ce bloque de code permet de calculer les GAMs ou les interpolation log-linéaires, afin de lisser les séries. Puis il calcule le taux de croissance (lambda) par année et par population avant de moyenne ces taux par une espèce. 
```{r}
for(I in sNames) {
    
    cat(".")
    Index = 1
    if (length(which(objects() == "sIndex")) != 0) {
      rm(sIndex)
    }
    SP = toString(sNames[asso_SPNames_Number%>%
                           filter(binomial == I)%>%
                           pull(number)])
    sIndex = which(Species == SP)
    SpeciesIndex = asso_SPNames_Number%>%
      filter(binomial == I)%>% 
      pull(number)
    
    PopID = unique(ID[sIndex, 1])
    
    if (length(which(objects() == "PopLambda")) != 0) {
      rm(PopLambda)
    }
    PopIDSize = length(PopID)
    PopLambda = matrix(NA, PopIDSize, FinalYear - REF_YEAR + 
                         1)
    JIndex = 1
    
    
    ### Enlever les zéros pour une pop
    
    #choisir la population J de l'espèce I
    for (J in 1:PopIDSize) {
      compteur = compteur+1
      IndexPop = which(ID == PopID[J])
      YearPop = Year[IndexPop, 1]
      #cat("Espece : ", SP, "Pop :", PopID[J], "\n")
      # First_year_pop = YearPop[1]
      # Last_year_pop = YearPop[length(YearPop)]
      PopN = Popvalue[IndexPop, 1]
      
      if(length(PopN) > 1){
        
        PopN = remove_zero(PopN)
        
        ###############
        
        SortResults = sort(YearPop, index.return = TRUE)
        YearPop = SortResults$x
        TempI = SortResults$ix
        PopN = PopN[TempI]
        
        ### Vide les variables à utiliser
        if (length(which(objects() == "YearPopInt")) != 
            0) {
          rm(YearPopInt)
        }
        if (length(which(objects() == "PopNInt")) != 
            0) {
          rm(PopNInt)
        }
        if (length(which(objects() == "PopNInt_se")) != 
            0) {
          rm(PopNInt_se)
        }
        
        
        
        #Toutes les années entre la première et la dernière valeur
        YearPopInt = YearPop[1]:YearPop[length(YearPop)]
        PopNLog = log(PopN) # Prendre le log des populations
        GAm_Flag = T
        if (var(PopN) == 0) {
          #cat(sprintf("Variance de PopN = %d\n", var(PopN)))
          GAm_Flag = F
        }
        
        SmoothParm = round(length(PopN)/2)
        
        ### GAM 
        # Si le Smoothparam est inférieur à 3 alors pas de GAM
        
        if (SmoothParm >= 3 & GAm_Flag == T) {
          #cat("GAM_MODEL\n")
          
          res_fit_gam_model = fit_gam_model(SmoothParm, PopNLog, YearPop)
          
          
          if(!is.null(res_fit_gam_model)){
            PopNInt_se = res_fit_gam_model$PopNInt_se
            PopNInt = res_fit_gam_model$PopNInt
            model_used = c("GAM")
            model_valid_used = c("GAM")
            PopPredict = bind_rows(PopPredict, c("binomial" = SP, "id"= PopID[J], 
                                                 "Model" = model_used, "Model_valide" = model_valid_used,"Smooth_para" = SmoothParm,
                                                 setNames(c(PopNInt),YearPopInt),
                                                 setNames(c(PopNInt_se),
                                                          paste(seq(min(YearPopInt),max(YearPopInt), by = 1), "_se", sep = ""))))
          }
        }
        
        #LINEAR_MODEL_FLAG = readline(prompt = "Press 'TRUE' to LINEAR_MODEL, 'F' to go to CHAIN_MODEL")
        
        # if(LINEAR_MODEL_FLAG == TRUE) {### Sinon pas de GAM
        #   #cat("LINEAR_MODEL\n")
        #   res_fit_linear_model = fit_linear_model(YearPop, PopNLog)
        #   PopNInt_lm = res_fit_linear_model$PopNInt
        #   PopNInt_lm_se = res_fit_linear_model$PopNInt_se
        #   model_used = c("Linear")
        #   PopPredict = bind_rows(PopPredict, c("binomial" = SP, "id"= PopID[J], 
        #                                        "Model" = model_used,
        #                                        setNames(c(PopNInt_lm),YearPopInt),
        #                                        setNames(c(PopNInt_lm_se),
        #                                                 paste(seq(min(YearPopInt),max(YearPopInt), by = 1), "_se", sep = ""))))
        # }
        
        #CHAIN_MODEL_FLAG = readline(prompt = "Press 'TRUE' to CHAIN_MODEL, 'F' ")
        
        if(CHAIN_MODEL_FLAG == TRUE) {
          #cat("CHAIN_MODEL\n")
          model_used = "Chain_model"
          
          if("GAM" %in% (PopPredict%>%
                         filter(id == PopID[J])%>%
                         pull(Model_valide))){
            
            model_used = "Chain_model"
            # Apply the default approach (Chain)
            
            PopNInt_chain =  fit_chain_model(YearPopInt, YearPop,PopN)$PopNInt
            PopNInt_chain_se = fit_chain_model(YearPopInt, YearPop,PopN)$PopNInt_se
            PopPredict = bind_rows(PopPredict, c("binomial" = SP, "id"= PopID[J],
                                                 "Model" = model_used,
                                                 setNames(c(PopNInt_chain),YearPopInt),
                                                 setNames(c(PopNInt_chain_se),
                                                          paste(seq(min(YearPopInt),max(YearPopInt), by = 1), "_se", sep = ""))))
            
          }
          
          
          else {
            model_valid_used = "Chain_model"
            model_used = "Chain_model"
            PopNInt =  fit_chain_model(YearPopInt, YearPop,PopN)$PopNInt
            PopNInt_se = fit_chain_model(YearPopInt, YearPop,PopN)$PopNInt_se
            PopPredict = bind_rows(PopPredict, c("binomial" = SP, "id"= PopID[J],
                                                 "Model" = model_used,
                                                 "Model_valide" = model_valid_used,
                                                 setNames(c(PopNInt),YearPopInt),
                                                 setNames(c(PopNInt_se),
                                                          paste(seq(min(YearPopInt),max(YearPopInt), by = 1), "_se", sep = ""))))
            
          }
        }
        
        #Enlever les Zeros des prédictions et mettre en log 
        #Le Living Planet Index (LPI) est souvent calculé sur les moyennes 
        #géométriques de populations standardisées, et ça se fait bien avec des log.
        
        {
          YearPop = InitialYear:FinalYear
          PopN = matrix(0, 1, length(YearPop))
          k = which(PopNInt == 0)
          k1 = which(PopNInt > 0)
          TempVal = 0
          if (length(k) > 0) {
            if (length(k1) > 0) {
              TempVal = mean(PopNInt[k1]) * 0.01
              PopNInt = PopNInt + TempVal
            }
          }
          for (K in InitialYear:FinalYear) {
            k = which(YearPopInt == K)
            if (length(k) > 0) {
              if (PopNInt[k] == 0) {
                PopN[K - InitialYear + 1] = NA
              }
              else {
                #Mettre en Log10 les populations prédites 
                PopN[K - InitialYear + 1] = log10(PopNInt[k])
              }
            }
            else {
              PopN[K - InitialYear + 1] = NA
            }
          }
        }
        
        ###### Calculate the growth rate
        {
          PopLambda = calcul_lambda_pop(PopLambda, JIndex, FinalYear, PopN, InitialYear, REF_YEAR)
          JIndex = JIndex + 1
        }
        
        #################################################### FIN BOUCLE POPULATION
      }
      else{ 
        cat("Less than 2 obs for population :", PopID[J], "\n")}
    }
    # Save the population lamdas to a file:
    PopData = cbind(as.vector(PopID), PopLambda)
    
    
    ####################################### Save the species average lambda values
    {
      res_calcul_lambda_species = calcul_lambda_species(InitialYear = InitialYear,
                                                        FinalYear = FinalYear,
                                                        PopLambda = PopLambda,
                                                        SpeciesIndex = SpeciesIndex,
                                                        REF_YEAR = REF_YEAR,
                                                        LAMBDA_MAX = LAMBDA_MAX,
                                                        LAMBDA_MIN = LAMBDA_MIN)
      data_SpeciesLambda_2002[SpeciesIndex,] = res_calcul_lambda_species$SpeciesLambda[SpeciesIndex,]
      #nb_pop_year_lambda = nb_pop_year_lambda + res_calcul_lambda_species$nb_pop_year_lambda
    }
    ############################################################ FIN BOUCLE ESPECE
  }

```

Afin de vérifier les données prédites, il est possible de les récupérer et de les visualiser.

```{r, warning=FALSE, fig.width=22, fig.height=17}
PopPredict_pivot = PopPredict%>%
  mutate(dept = substr(id, 1, 2))%>%
  pivot_longer(cols = as.character(1990:2024),
               names_to = "year", 
               values_to = "popvalue") %>%
  pivot_longer(cols = ends_with("_se"),
               names_to = "year_se", 
               values_to = "se") %>%
  mutate(year_se = str_remove(year_se, "_se")) %>%
  filter(year == year_se)%>%
  mutate(year = as.numeric(year),
         popvalue = as.numeric(popvalue),
         se = as.numeric(se),
         IC_lower = popvalue - 1.96 * se,
         IC_upper = popvalue + 1.96 * se)


ggplot() +
  geom_line(data = PopPredict_pivot%>%
              filter(!(is.na(Model_valide)))%>%
              mutate(popvalue =  (popvalue),
                     IC_lower =  (IC_lower),
                     IC_upper =  (IC_upper)),
            aes(x = year, y = popvalue, color = as.factor(dept), group = dept), linewidth = 1.3)+
  geom_ribbon(data = PopPredict_pivot%>%
                filter(!(is.na(Model_valide)))%>%
                mutate(popvalue =  (popvalue),
                       IC_lower =  (IC_lower),
                       IC_upper =  (IC_upper)),
              aes(x = year, ymin = IC_lower, ymax = IC_upper, fill =  as.factor(dept),
                  group = dept), alpha = 0.6) +
  geom_line(data = data_nicheur_clean%>%
              mutate(popvalue =  (popvalue)),
            aes(x = year, y = popvalue, color = as.factor(dept), group = dept), linetype = 2) +
  geom_point(data = data_nicheur_clean%>%
               mutate(popvalue =  (popvalue)),
             aes(x = year, y = popvalue, color = as.factor(dept), group = dept), size = 0.9, alpha = 0.2) +
  scale_color_manual(values = color_dept) +
  scale_fill_manual(values = color_dept) +
  labs(title = "Tendances de toutes les espèces pour toutes les séries temporelles",
       color = "Departements :", x = "Annee") +
  facet_wrap(~binomial, scales = "free_y") +
  scale_x_continuous(limits = c(1990, 2024)) +
  theme_bw() +
  theme(legend.position = "bottom")
```



##### *3) Calcul de l'IAV :*   


```{r}
#Pour fermer les connections ouvertes car le LPI en prend beaucoup
closeAllConnections()
#Calcul des Dtemp (le taux de croissance total par année)
results_DTemp = calcul_dtemp(data_SpeciesLambda_2002, CAP_LAMBDAS)
DTemp_2002 = results_DTemp$DTemp
nb_sp_year_dtemp = nb_sp_year_dtemp + results_DTemp$nb_sp_year_dtemp

#Paramètre pour le LPI
PLOT_MAX = FinalYear
REF_YEAR = 2002
DSize = PLOT_MAX - REF_YEAR + 1

#Calcul de l'indice à partir des Dtemp 
Ifinal = calcul_index(DTemp_2002, DSize, REF_YEAR, InitialYear)
valid_index_years = ((!is.na(Ifinal)) & (Ifinal != -99))


Ifinal = Ifinal%>%
  as_tibble()%>%
  mutate(LPI_final = V1,
         year = REF_YEAR:PLOT_MAX)%>%
  select(-V1)

#Calcul de l'intervalle de confiance à partir des bootstraps 
Ifinal_IC = calcul_IC(BOOT_STRAP_SIZE = 1000, DSize, data_SpeciesLambda_2002, 
                      InitialYear, REF_YEAR)$IC

Ifinal_IC = Ifinal_IC%>%
  as_tibble()%>%
  rename_with(~ c("IC_low", "IC_high"))%>%
  mutate(year = REF_YEAR : PLOT_MAX)


Ifinal_selection_2002 = left_join(Ifinal, Ifinal_IC, by = join_by(year))
```

L'Indice Avifaune Vivante à partir de 2002 :  
```{r}

ggplot(Ifinal_selection_2002,
       aes(x =year)) +
  geom_line(aes(y = LPI_final), color = "#0087CD", size = 1.5) +
  geom_ribbon(aes(x = year, ymin = IC_low, ymax = IC_high),fill = "#0087CD", alpha = 0.1) +
  geom_hline(yintercept = 1, color = "grey")+
  scale_y_continuous(limits = c(0.5,2))+
  scale_x_continuous(breaks = seq(2002, 2024, by = 2))+
  
  labs(x = "Année", y = "IAV (2002 = 1)") +
  theme_bw()+
  theme(legend.position = "none")
```


Le nombre d'espèce par année utilisées dans le calcul:  
```{r}

Ifinal_selection_2002$nb_esp = colSums(!is.na(data_SpeciesLambda_2002))

ggplot(Ifinal_selection_2002,
       aes(x =year)) +
  geom_line(aes(y = nb_esp), color = "#F55F19", size = 1.5) +
  scale_y_continuous(limits = c(60,105))+
  scale_x_continuous(breaks = seq(2002, 2024, by = 2))+
  
  labs(x = "Année", y = "Nombre d'espèces par année") +
  theme_bw()+
  theme(legend.position = "none")
```


##### *4) Contribution individuelle des espèces :*   

A partir de ces données, il est possible de connaitre la contribution de chaque espèce à l'IAV. Pour cela, l'IAV est recalculé après le retrait de chaque espèce unes à unes. Chaque courbe sur le graphique ci-dessous représente l'IAV sans une espèce. Pour savoir quelle espèce influence le plus, un graphique est disponible juste après.


```{r}
leverage_results <- list()
leverage_results_IC <- list()
leverage_diff <- list()
leverage_species <- list()

overall_lambdas <- calcul_lambdas_LPI(Ifinal_selection_2002$LPI_final)

for (i in 1:nrow(data_SpeciesLambda_2002)) {
  cat(i, " ; ")
  # SpeciesLambdaArray = SpeciesLambdaArray[-i, ]
  DTemp_lev = calcul_dtemp((data_SpeciesLambda_2002[-i, ]), CAP_LAMBDAS)$DTemp
  
  lev_I <- calcul_index(DTemp_lev, DSize, InitialYear = 2002, REF_YEAR = 2002)
  #lambda_lev_I <- calcul_leverage_LPI(SpeciesLambda[-i, ], DSize)$Valide_speciesLambda
  
  leverage_results[[i]] <- lev_I
  leverage_results_IC[[i]] <-   calcul_IC(BOOT_STRAP_SIZE = 1000, DSize, SpeciesLambda = (data_SpeciesLambda_2002[-i, ]), InitialYear = 2002, REF_YEAR = 2002)
  leverage_diff[[i]] <- calcul_lambdas_LPI(lev_I) - overall_lambdas
  leverage_species[[i]] <- sNames[i]
}


# Combine list of vectors from foreach into matrix
leverage_results <- do.call(cbind, leverage_results)
# Transpose matrix as each bootstrap loop is a column and we'd like them to be rows
leverage_results <- t(leverage_results)
# Combine list of vectors from foreach into matrix
leverage_diff <- do.call(cbind, leverage_diff)
# Transpose matrix as each bootstrap loop is a column and we'd like them to be rows
leverage_diff <- t(leverage_diff)

leverage_results_table <- data.frame(leverage_results)
colnames(leverage_results_table) <- seq(REF_YEAR, REF_YEAR + DSize - 1)

# leverage_results_table$total <- rowSums(leverage_results_table)

leverage_results_table$binomial <- unlist(leverage_species)
leverage_diff_table <- data.frame(leverage_diff)
colnames(leverage_diff_table) <- seq(REF_YEAR, REF_YEAR + DSize - 1)
leverage_diff_table$total <- rowSums(leverage_diff_table)
leverage_diff_table$id <- unlist(leverage_species)


leverage_results_table = leverage_results_table%>%
  pivot_longer(cols = as.character(2002:2024), names_to = "year", values_to = "LPI") %>%
  left_join(data_nicheur_clean %>% select(binomial, domaine.alauda_2016)%>%
              distinct(binomial, .keep_all = TRUE), by = "binomial")
# 
# 
# leverage_results_IC = map2_dfr(leverage_results_IC, seq_along(leverage_results_IC), ~ {
#   data.frame(
#     binomial = .y,
#     year = 2002:2024,
#     IC_low = .x[, 1],
#     IC_high = .x[, 2]
#   )
# })
# 
# species_lookup <- setNames(leverage_species, 1:length(leverage_species))
# 
# leverage_results_IC$binomial = species_lookup[as.character(leverage_results_IC$binomial)]
# leverage_results_IC$binomial <- as.character(leverage_results_IC$binomial)
```


```{r, fig.width= 10, fig.height=7}
ggplot()+
  geom_line(data = leverage_results_table,
            aes(x = as.numeric(year), y = LPI, color = binomial, group = binomial), linewidth = 1)+
  geom_line(data = Ifinal_selection_2002,
            aes(x = as.numeric(year), y = LPI_final), linewidth = 1)+
  # geom_ribbon(data = LPI_IAV_aqua_selectif%>%
  #               rownames_to_column(var = "year")%>%
  #               mutate(year = as.numeric(year)),
  # aes(x = year, y = LPI_final, ymin = CI_low, ymax = CI_high), alpha = 0.1) +
  geom_hline(yintercept = 1)+
  labs(title = "IAV (2002 = 1) - Contribution individuelle des espèces")+
  scale_y_continuous(limits = c(0.5,2))+
  scale_x_continuous(breaks = seq(2002, 2024, by = 2))+
  theme_bw()+
  theme(legend.position = "none",
  )
```

Le graphique ci-dessous représente l'influence d'une espèce sur la valeur finale de l'IAV (soit la valeur à l'année 2024). Pour chaque espèce, la valeur affichée sur le graphique correspond à $IAV sans -IAV avec$ l'espèce en question. Si la valeur est positive, alors le retrait de l'espèce fait augmenter l'IAV donc l'espèce a une influence négative (souvent des espèces en déclin) et inversement.
```{r, fig.width= 7, fig.height=15}
ggplot(
  cbind(leverage_results_table %>%
          filter(year == 2024),
        Ifinal_selection_2002%>%
          select(LPI_final)%>%
          as_tibble() %>%
          mutate(year = 2002:2024) %>%
          filter(year == 2024) %>%
          select(LPI_final))%>%
    mutate(Diff = LPI - LPI_final,
           Val = ifelse(Diff < 0, "negatif", "positif")) %>%
    arrange(Diff) %>%
    mutate(binomial = factor(binomial, levels = binomial))  # Forcer l’ordre ici
  , aes(x = Diff, y = binomial, fill = Val)
) + 
  geom_bar(stat = "identity") + 
  labs(
    title = "Effet de retrait d'une espèce sur la valeur de l'IAV 2002", 
    x = "Effet (IAV sans l'espèce - IAV global)", 
    y = "Espèce retirée"
  ) + 
  scale_fill_manual(values = c("negatif" = "#7A1A48", "positif" = "#31a354")) +
  theme_bw() +
  theme(
    axis.text.y = element_text(size = 8),
    title = element_text(size = 8),
    legend.position = "bottom"
  )
```


#### *4 - Calcul des sous-indicateurs*


Une fonction pour les gouverner...euuuh les calculer TOUS : calcul_indicateur() trouvable dans le fichier Fonction_IAV.R

Calculer tous les indicateurs un par un selon la variable que l'on souhaite regarder.  


Cela signifie qu'il n'y a pas de valeur pour la 21ème année.

###### Indicateur par domaine :

```{r}
res_domaine <- calcul_indicateur(
  data = data_nicheur_clean,
  var_groupe = "domaine.alauda_2016",
  data_SpeciesLambda_2002 = data_SpeciesLambda_2002,
  CAP_LAMBDAS = CAP_LAMBDAS,
  FinalYear = FinalYear,
  InitialYear = InitialYear,
  sNames = sNames,
  data_all = data_all_nicheur
)
```

Création des graphiques (à personnaliser).  

Pour le premier, il permet de récupérer les graphiques individuellements (il suffit de remplacer "agricole" par un autre domaine).

```{r}
ggplot(res_domaine$leverage%>%filter(domaine.alauda_2016 == "agricole"),
       aes(x = as.numeric(year), y = LPI_final)) +
  geom_line(aes(x = as.numeric(year), y = LPI, group = binomial), color = "grey", linewidth = 1, alpha = 0.2)+
  geom_line(data = res_domaine$Ifinal%>%filter(domaine.alauda_2016 == "agricole"),aes(x = as.numeric(year), y = LPI_final, color = domaine.alauda_2016), linewidth = 1.3)+
  geom_ribbon(data = res_domaine$Ifinal%>%filter(domaine.alauda_2016 == "agricole"),aes(x = as.numeric(year), y = LPI_final, ymin = IC_low, ymax = IC_high, fill = domaine.alauda_2016,
                                                                                        color = domaine.alauda_2016), alpha = 0.1)+
  geom_hline(yintercept = 1)+
  facet_wrap(~domaine.alauda_2016, ncol = 2, scales = "free_y",
             labeller = labeller(
               domaine.alauda_2016 = c(
                 agricole = paste("Agricole (",  res_domaine$nb_sp_max$agricole, " espèces)", sep = "" ),
                 aquatique =  paste("Aquatique (",  res_domaine$nb_sp_max$aquatique, " espèces)", sep = "" ),
                 forestier =  paste("Forestier (",  res_domaine$nb_sp_max$forestier, " espèces)", sep = "" ),
                 maritime =  paste("Maritime (",  res_domaine$nb_sp_max$maritime, " espèces)", sep = "" ),
                 "rocheux/bati" =  paste("Rocheux et bâti (",  res_domaine$nb_sp_max$`rocheux/bati`, " espèces)", sep = "" )
               ))
  )+
  scale_color_manual(values = color_domaine)+
  scale_fill_manual(values = color_domaine)+
  labs(x = "Année", y = "IAV (2002 = 1)")+
  
  scale_x_continuous(breaks = seq(2002, 2024, by = 2))+
  scale_y_continuous(limits = c(0.5, 1.3))+
  theme_bw()+
  theme(legend.position = "none")
```


```{r, fig.width= 10, fig.height=7}
ggplot()+
  geom_line(data = res_domaine$leverage,
            aes(x = as.numeric(year), y = LPI, group = binomial), color = "grey", linewidth = 1, alpha = 0.2)+
  geom_line(data = res_domaine$Ifinal,aes(x = as.numeric(year), y = LPI_final, color = domaine.alauda_2016), linewidth = 1.3)+
  geom_ribbon(data = res_domaine$Ifinal,aes(x = as.numeric(year), y = LPI_final, ymin = IC_low, ymax = IC_high, fill = domaine.alauda_2016,
                                            color = domaine.alauda_2016), alpha = 0.1)+
  geom_hline(yintercept = 1)+
  labs( x = "Année",
        y = "IAV (2002 = 1)")+
  scale_color_manual(values = color_domaine)+
  scale_fill_manual(values = color_domaine)+
  scale_x_continuous(breaks = seq(2002, 2024, by = 2))+
  
  facet_wrap(~domaine.alauda_2016,ncol = 2,  scales = "free_y",
             labeller = labeller(
               domaine.alauda_2016 = c(
                 agricole = paste("Agricole (", res_domaine$nb_sp_max$agricole, " espèces)", sep = "" ),
                 aquatique =  paste("Aquatique (",  res_domaine$nb_sp_max$aquatique, " espèces)", sep = "" ),
                 forestier =  paste("Forestier (",  res_domaine$nb_sp_max$forestier, " espèces)", sep = "" ),
                 maritime =  paste("Maritime (",  res_domaine$nb_sp_max$maritime, " espèces)", sep = "" ),
                 "rocheux/bati" =  paste("Rocheux et bâti (",  res_domaine$nb_sp_max$`rocheux/bati`, " espèces)", sep = "" )
               )))+
  theme_bw()+
  theme(legend.position = "none",
  )
```



###### Indicateur par milieu spécifique (gpe) :


```{r}
res_gpe <- calcul_indicateur(
  data = data_nicheur_clean,
  var_groupe = "gpe.classif.alauda_2016",
  data_SpeciesLambda_2002 = data_SpeciesLambda_2002,
  CAP_LAMBDAS = CAP_LAMBDAS,
  FinalYear = FinalYear,
  InitialYear = InitialYear,
  sNames = sNames,
  data_all = data_all_nicheur
)

```

```{r, fig.width= 10, fig.height=7}
label_gpe = c(
  "1. milieux ruraux heterogenes" = paste("Milieux ruraux heterogenes (", res_gpe$nb_sp_max$`1. milieux ruraux heterogenes`, " espèces)", sep = "" ),
  "2. landes, fourres, coupes" = paste("Landes, fourres, coupes (", res_gpe$nb_sp_max$`2. landes, fourres, coupes`, " espèces)", sep = "" ),
  "3. vieilles forets de plaine" = paste("Vieilles forets de plaine (", res_gpe$nb_sp_max$`3. vieilles forets de plaine`, " espèces)", sep = "" ),
  "4. forets de montagne" =  paste("Forets de montagne (", res_gpe$nb_sp_max$`4. forets de montagne`, " espèces)", sep = "" ),
  #"5. maquis, garrigues" =paste("Maquis, garrigues (", " espèces)", sep = "" ),
  #"6. steppes, openfields" = paste("Steppes, openfields (", res_gpe$nb_sp_max$, " espèces)", sep = "" ),
  "7. prairies humides" = paste("Prairies humides (", res_gpe$nb_sp_max$`7. prairies humides`, " espèces)", sep = "" ),
  #"8. cotes sableuses" = paste("Cotes sableuses (", res_gpe$nb_sp_max$, " espèces)", sep = "" ),
  "9. villes, villages" =paste("Villes, villages (", res_gpe$nb_sp_max$`9. villes, villages`, " espèces)", sep = "" ),
  "10. cotes rocheuses" =paste("Cotes rocheuses (", res_gpe$nb_sp_max$`10. cotes rocheuses`, " espèces)", sep = "" ),
  "11. roselieres" = paste("Roselieres (", res_gpe$nb_sp_max$`11. roselieres`, " espèces)", sep = "" ),
  "12. marais" =paste("Marais (", res_gpe$nb_sp_max$`12. marais`, " espèces)", sep = "" ),
  "13. plans d'eau" = paste("Plans d'eau (", res_gpe$nb_sp_max$`13. plans d'eau`, " espèces)", sep = "" ),
  "14. rivieres a lit mobile" = paste("Rivieres a lit mobile (", res_gpe$nb_sp_max$`14. rivieres a lit mobile`, " espèces)", sep = "" ),
  "15. ripisylves" =paste("Ripisylves (", res_gpe$nb_sp_max$`15. ripisylves`, " espèces)", sep = "" ),
  #"16. torrents" = paste("Torrents (", res_gpe$nb_sp_max$, " espèces)", sep = "" ),
  "17. rochers, falaises" = paste("Rochers, falaises (", res_gpe$nb_sp_max$`17. rochers, falaises`, " espèces)", sep = "" )
)


ggplot()+
  geom_line(data = res_gpe$leverage,
            aes(x = as.numeric(year), y = LPI, group = binomial), color = "grey", linewidth = 1, alpha = 0.2)+
  geom_line(data = res_gpe$Ifinal,aes(x = as.numeric(year), y = LPI_final, color = gpe.classif.alauda_2016), linewidth = 1.3)+
  geom_ribbon(data = res_gpe$Ifinal,aes(x = as.numeric(year), y = LPI_final, ymin = IC_low, ymax = IC_high, fill = gpe.classif.alauda_2016,
                                        color = gpe.classif.alauda_2016), alpha = 0.1)+
  geom_hline(yintercept = 1)+
  labs( x = "Année",
        y = "IAV (2002 = 1)")+
  scale_color_manual(values = color_gpe)+
  scale_fill_manual(values = color_gpe)+
  scale_x_continuous(breaks = seq(2002, 2024, by = 2))+
  
  facet_wrap(~gpe.classif.alauda_2016,ncol = 2,  scales = "free_y",
             labeller = labeller(
               gpe.classif.alauda_2016 = label_gpe))+
  theme_bw()+
  theme(legend.position = "none",
  )
```



###### Indicateur par type de migration :  

```{r}
res_migration <- calcul_indicateur(
  data = data_nicheur_clean,
  var_groupe = "migrateur",
  data_SpeciesLambda_2002 = data_SpeciesLambda_2002,
  CAP_LAMBDAS = CAP_LAMBDAS,
  FinalYear = FinalYear,
  InitialYear = InitialYear,
  sNames = sNames,
  data_all = data_all_nicheur
)

```

```{r, fig.width= 10, fig.height=4}
ggplot(res_migration$Ifinal%>%filter(!is.na(migrateur)),
       aes(x = as.numeric(year), y = LPI_final)) +
  geom_line(data = res_migration$leverage%>%filter(!is.na(migrateur)),
            aes(x = as.numeric(year), y = LPI, group = binomial), color = "grey", linewidth = 1, alpha = 0.4)+
  geom_line(aes(color = migrateur),linewidth = 1.3)+
  geom_ribbon(aes(ymin = IC_low, ymax = IC_high, fill = migrateur), alpha = 0.1)+
  geom_hline(yintercept = 1)+
  
  labs(x = "Année", y = "IAV (2002 = 1)")+
  scale_x_continuous(breaks = seq(2002, 2024, by = 2))+
  scale_color_manual(values = color_migration)+
  scale_fill_manual(values = color_migration)+
  facet_wrap(~migrateur, ncol = 2,#scales = "free_y",
             labeller = labeller(
               migrateur = c(
                 partiel = paste("Migrateur partiel (", res_migration$nb_sp_max$partiel, " espèces)", sep = "" ),
                 sedentaire =  paste("Sedentaire (", res_migration$nb_sp_max$sedentaire, " espèces)", sep = "" ),
                 "trans-saharien" =  paste("Migrateur trans-saharien (", res_migration$nb_sp_max$`trans-saharien`, " espèces)", sep = "" )
               )))+
  theme_bw()+
  theme(legend.position = "none")

```



###### Indicateur par affinité thermique :  

```{r}
res_affinite.thermique <- calcul_indicateur(
  data = data_nicheur_clean,
  var_groupe = "affinite.thermique",
  data_SpeciesLambda_2002 = data_SpeciesLambda_2002,
  CAP_LAMBDAS = CAP_LAMBDAS,
  FinalYear = FinalYear,
  InitialYear = InitialYear,
  sNames = sNames,
  data_all = data_all_nicheur
)

```

```{r, fig.width= 10, fig.height=4}
ggplot(res_affinite.thermique$Ifinal%>%filter(!is.na(affinite.thermique)),
       aes(x = as.numeric(year), y = LPI_final)) +
  geom_line(data = res_affinite.thermique$leverage%>%filter(!is.na(affinite.thermique)),
            aes(x = as.numeric(year), y = LPI, group = binomial), color = "grey", linewidth = 1, alpha = 0.4)+
  geom_line(aes(color = affinite.thermique),linewidth = 1.3)+
  geom_ribbon(aes(ymin = IC_low, ymax = IC_high, fill = affinite.thermique), alpha = 0.1)+
  geom_hline(yintercept = 1)+
  
  labs(x = "Année", y = "IAV (2002 = 1)")+
  scale_x_continuous(breaks = seq(2002, 2024, by = 2))+
  scale_color_manual(values = color_affinite.thermique)+
  scale_fill_manual(values = color_affinite.thermique)+
  facet_wrap(~affinite.thermique, ncol = 2,#scales = "free_y",
             labeller = labeller(
               affinite.thermique = c(
                 meridionale = paste("Meridionale (", res_affinite.thermique$nb_sp_max$meridionale, " espèces)", sep = "" ),
                 septentrionale =  paste("Septentrionale (", res_affinite.thermique$nb_sp_max$septentrionale, " espèces)", sep = "" )
               )))+
  theme_bw()+
  theme(legend.position = "none")

```


###### Indicateur par hauteur de nidification :  

```{r}
res_hauteur.nidif <- calcul_indicateur(
  data = data_nicheur_clean,
  var_groupe = "hauteur_nidif",
  data_SpeciesLambda_2002 = data_SpeciesLambda_2002,
  CAP_LAMBDAS = CAP_LAMBDAS,
  FinalYear = FinalYear,
  InitialYear = InitialYear,
  sNames = sNames,
  data_all = data_all_nicheur
)

```

```{r, fig.width= 7, fig.height=4}
ggplot(res_hauteur.nidif$Ifinal,
       aes(x = as.numeric(year), y = LPI_final)) +
  geom_line(data = res_hauteur.nidif$leverage,
            aes(x = as.numeric(year), y = LPI, group = binomial), color = "grey", linewidth = 1, alpha = 0.4)+
  geom_line(aes(color = as.factor(hauteur_nidif)),linewidth = 1.3)+
  geom_ribbon(aes(ymin = IC_low, ymax = IC_high, fill =  as.factor(hauteur_nidif)), alpha = 0.1)+
  geom_hline(yintercept = 1)+
  
  labs(x = "Année", y = "IAV (2002 = 1)", hauteurr = "hauteur_nidiff :")+
  scale_x_continuous(breaks = seq(2002, 2024, by = 2))+
  #scale_y_continuous(limits = c(0,1.5))+
  scale_color_manual(values = color_hauteur_nidif)+
  scale_fill_manual(values = color_hauteur_nidif)+
  
  facet_wrap(~hauteur_nidif, scales = "free_y",
             labeller = labeller(
               hauteur_nidif = c(
                 bas = paste("Bas (", res_hauteur.nidif$nb_sp_max$bas, " espèces)", sep = "" ),
                 haut =  paste("Haut (", res_hauteur.nidif$nb_sp_max$haut, " espèces)", sep = "" ),
                 inclassable = paste("Inclassable (", res_hauteur.nidif$nb_sp_max$inclassable, " espèces)", sep = "" ),
                 sol = paste("Sol (", res_hauteur.nidif$nb_sp_max$sol, " espèces)", sep = "" )
               )))+
  theme_bw()+
  theme(legend.position = "none")
```

###### Indicateur par degré de spécialisation :  

```{r}
res_specialisation <- calcul_indicateur(
  data = data_nicheur_clean,
  var_groupe = "specialisation",
  data_SpeciesLambda_2002 = data_SpeciesLambda_2002,
  CAP_LAMBDAS = CAP_LAMBDAS,
  FinalYear = FinalYear,
  InitialYear = InitialYear,
  sNames = sNames,
  data_all = data_all_nicheur
)

```


```{r, fig.width= 10, fig.height=4}
ggplot(res_specialisation$Ifinal,
       aes(x = as.numeric(year), y = LPI_final)) +
  geom_line(data = res_specialisation$leverage,
            aes(x = as.numeric(year), y = LPI, group = binomial), color = "grey", linewidth = 1, alpha = 0.4)+
  geom_line(aes(color = specialisation),linewidth = 1.3)+
  geom_ribbon(aes(ymin = IC_low, ymax = IC_high, fill = specialisation), alpha = 0.1)+
  geom_hline(yintercept = 1)+
  labs(x = "Année", y = "IAV (2002 = 1)")+
  scale_x_continuous(breaks = seq(2002, 2024, by = 2))+
  scale_color_manual(values = color_gene, name = NULL)+
  scale_fill_manual(values = color_gene, name = NULL)+
  
  facet_wrap(~specialisation,# scales = "free_y",
             labeller = labeller(
               specialisation = c(
                 gene = paste("Généraliste (", res_specialisation$nb_sp_max$gene, " espèces)", sep = "" ),
                 spe =  paste("Spécialiste (", res_specialisation$nb_sp_max$spe, " espèces)", sep = "" )
               )))+
  theme_bw()+
  theme(legend.position = "none")
```



###### Indicateur par type de cavicole :  

```{r}
res_cavicole <- calcul_indicateur(
  data = data_nicheur_clean,
  var_groupe = "cavicole",
  data_SpeciesLambda_2002 = data_SpeciesLambda_2002,
  CAP_LAMBDAS = CAP_LAMBDAS,
  FinalYear = FinalYear,
  InitialYear = InitialYear,
  sNames = sNames,
  data_all = data_all_nicheur
)

```


```{r, fig.width= 10, fig.height=4}
ggplot(res_cavicole$Ifinal,
       aes(x = as.numeric(year), y = LPI_final)) +
  geom_line(data = res_cavicole$leverage,
            aes(x = as.numeric(year), y = LPI, group = binomial), color = "grey", linewidth = 1, alpha = 0.4)+
  geom_line(aes(color = cavicole),linewidth = 1.3)+
  geom_ribbon(aes(ymin = IC_low, ymax = IC_high, fill = cavicole), alpha = 0.1)+
  geom_hline(yintercept = 1)+
  
  labs(x = "Année", y = "IAV (2002 = 1)")+
  scale_x_continuous(breaks = seq(2002, 2024, by = 2))+
  scale_color_manual(values = color_cavicole, name = NULL)+
  scale_fill_manual(values = color_cavicole, name = NULL)+
  
  facet_wrap(~cavicole,ncol = 2, #scales = "free_y",
             labeller = labeller(
               cavicole = c(
                 oui = paste("Cavicole (", res_cavicole$nb_sp_max$non, " espèces)", sep = "" ),
                 non =  paste("Non cavicole (", res_cavicole$nb_sp_max$oui, " espèces)", sep = "" ),
                 semi =  paste("Semi cavicole (", res_cavicole$nb_sp_max$semi, " espèces)", sep = "" )
               )))+
  theme_bw()+
  theme(legend.position = "none"
  )

```



###### Indicateur par type de colonial :  

```{r}
res_colonial <- calcul_indicateur(
  data = data_nicheur_clean,
  var_groupe = "colonial",
  data_SpeciesLambda_2002 = data_SpeciesLambda_2002,
  CAP_LAMBDAS = CAP_LAMBDAS,
  FinalYear = FinalYear,
  InitialYear = InitialYear,
  sNames = sNames,
  data_all = data_all_nicheur
)

```


```{r, fig.width= 10, fig.height=4}
ggplot(res_colonial$Ifinal,
       aes(x = as.numeric(year), y = LPI_final)) +
  geom_line(data = res_colonial$leverage,
            aes(x = as.numeric(year), y = LPI, group = binomial), color = "grey", linewidth = 1, alpha = 0.4)+
  geom_line(aes(color = as.factor(colonial)),linewidth = 1.3)+
  geom_ribbon(aes(ymin = IC_low, ymax = IC_high, fill = colonial), alpha = 0.1)+
  geom_hline(yintercept = 1)+
  
  labs(x = "Année", y = "IAV (2002 = 1)", color = "colonial :")+
  scale_x_continuous(breaks = seq(2002, 2024, by = 2))+
  #scale_y_continuous(limits = c(0,3.5))+
  scale_color_manual(values = color_colonial)+
  scale_fill_manual(values = color_colonial)+
  facet_wrap(~colonial, #scales = "free_y",
             labeller = labeller(
               colonial = c(
                 oui = paste("Colonial (", res_colonial$nb_sp_max$oui, " espèces)", sep = "" ),
                 non =  paste("Non colonial (", res_colonial$nb_sp_max$non, " espèces)", sep = "" )
               )))+
  theme_bw()+
  theme(legend.position = "none")
```





###### Indicateur par classement dans la liste rouge (hypothèses) :  

```{r}
res_lrnidif_bfc <- calcul_indicateur(
  data = data_nicheur_clean,
  var_groupe = "lrnidif_bfc.hypothese",
  data_SpeciesLambda_2002 = data_SpeciesLambda_2002,
  CAP_LAMBDAS = CAP_LAMBDAS,
  FinalYear = FinalYear,
  InitialYear = InitialYear,
  sNames = sNames,
  data_all = data_all_nicheur
)

```


```{r, fig.width= 10, fig.height=4}
ggplot(res_lrnidif_bfc$Ifinal,
       aes(x = as.numeric(year), y = LPI_final)) +
  geom_line(data = res_lrnidif_bfc$leverage,
            aes(x = as.numeric(year), y = LPI, group = binomial), color = "grey", linewidth = 1, alpha = 0.4)+
  geom_line(aes(color = as.factor(lrnidif_bfc.hypothese)),linewidth = 1.3)+
  geom_ribbon(aes(ymin = IC_low, ymax = IC_high, fill =  as.factor(lrnidif_bfc.hypothese)), alpha = 0.1)+
  geom_hline(yintercept = 1)+
  
  labs(x = "Année", y = "IAV (2002 = 1)", lrr = "lrnidif_bfc.hypothese :")+
  scale_x_continuous(breaks = seq(2002, 2024, by = 2))+
  #scale_y_continuous(limits = c(0,1.5))+
  scale_color_manual(values = c(cr = "#FF0000",
                                en = "#FFA500",
                                vu = "#FFFF00",
                                lc = "#008000",
                                nt = "#ADFF2F",
                                "grey60"))+
  scale_fill_manual(values = c(cr = "#FF0000",
                               en = "#FFA500",
                               vu = "#FFFF00",
                               lc = "#008000",
                               nt = "#ADFF2F",
                               "grey60"))+
  facet_wrap(~lrnidif_bfc.hypothese, ncol = 2,scales = "free_y",
             labeller = labeller(
               lrnidif_bfc.hypothese = c(
                 cr = paste("En danger critique (", res_lrnidif_bfc$nb_sp_max$cr, " espèces)", sep = "" ),
                 dd = paste("Données insuffisantes (", res_lrnidif_bfc$nb_sp_max$dd, " espèces)", sep = "" ),
                 en = paste("En danger (", res_lrnidif_bfc$nb_sp_max$en, " espèces)", sep = "" ),
                 lc = paste("Préoccupation mineur (", res_lrnidif_bfc$nb_sp_max$lc, " espèces)", sep = "" ),
                 nt = paste("Quasi-menacée (", res_lrnidif_bfc$nb_sp_max$nt, " espèces)", sep = "" ),
                 vu = paste("Vulnérable (", res_lrnidif_bfc$nb_sp_max$vu, " espèces)", sep = "" )
               )))+
  theme_bw()+
  theme(legend.position = "none")

```


###### Indicateur par statut de protection :  

```{r}
res_statut.protect <- calcul_indicateur(
  data = data_nicheur_clean,
  var_groupe = "protect_fra",
  data_SpeciesLambda_2002 = data_SpeciesLambda_2002,
  CAP_LAMBDAS = CAP_LAMBDAS,
  FinalYear = FinalYear,
  InitialYear = InitialYear,
  sNames = sNames,
  data_all = data_all_nicheur
)

```



```{r, fig.width= 10, fig.height=4}
ggplot(res_statut.protect$Ifinal,
       aes(x = as.numeric(year), y = LPI_final)) +
  geom_line(data = res_statut.protect$leverage,
            aes(x = as.numeric(year), y = LPI, group = binomial), color = "grey", linewidth = 1, alpha = 0.4)+
  geom_line(aes(color = as.factor(protect_fra)),linewidth = 1.3)+
  geom_ribbon(aes(ymin = IC_low, ymax = IC_high, fill =  as.factor(protect_fra)), alpha = 0.1)+
  geom_hline(yintercept = 1)+
  
  labs(x = "Année", y = "IAV (2002 = 1)", protectr = "protect_fra :")+
  scale_x_continuous(breaks = seq(2002, 2024, by = 2))+
  #scale_y_continuous(limits = c(0,1.5))+
  scale_color_manual(values = c("#E88E00","#E760A4","#4472C4","grey56"))+
  scale_fill_manual(values = c("#E88E00","#E760A4","#4472C4","grey56"))+
  facet_wrap(~protect_fra, ncol = 2, scales = "free_y",
             labeller = labeller(
               protect_fra = c(
                 chasse = paste("Espèces chassables (", res_statut.protect$nb_sp_max$chasse, " espèces)", sep = "" ),
                 `chasse-mor` =  paste("Espèces sous moratoire de chasse (", res_statut.protect$nb_sp_max$`chasse-mor`, " espèces)", sep = "" ),
                 `esp-biot` = paste("Espèces protégées (", res_statut.protect$nb_sp_max$`esp-biot`, " espèces)", sep = "" ),
                 na = paste("NA (", res_statut.protect$nb_sp_max$na, " espèces)", sep = "" )
               )))+
  theme_bw()+
  theme(legend.position = "none")
```





#### *5 - Calcul des indicateurs par départements* 



```{r}
Ifinal_selection_2002_dept = list()

for (departement in unique(data_nicheur_clean$dept)){
  
  data_nicheur_clean_dept = data_nicheur_clean%>%filter(dept == departement)
  
  #Données
  Species = data_nicheur_clean_dept["binomial"]
  ID = data_nicheur_clean_dept["id"]
  Year = data_nicheur_clean_dept["year"]
  Popvalue = data_nicheur_clean_dept["popvalue"]
  
  
  #Paramètrage
  REF_YEAR = 2002
  LINEAR_MODEL_FLAG = TRUE
  CHAIN_MODEL_FLAG = TRUE
  MethodFlagLoop = 0
  LAMBDA_MAX = 1
  LAMBDA_MIN = -1
  CAP_LAMBDAS = TRUE
  
  
  
  
  FinalYear = max(Year)
  InitialYear = min(Year)
  NumberYear = FinalYear - InitialYear +1
  
  
  noRecs = max(dim(Popvalue))
  sNames = unique(pull(Species))
  sID = unique(ID)
  noSpecies = max(dim(unique(Species)))
  noPop = max(dim(unique(ID)))
  MethodFlag = matrix(0, 1, noPop)
  
  sNamesCounter = 0
  sNamesArray = sNames
  sIDArray = sID
  
  asso_SPNames_Number = data.frame(
    binomial = sNames,
    number = seq_along(sNames),
    stringsAsFactors = FALSE
  )
  
  
  PopProcessedGAM = matrix(0, 1, noPop)
  
  #Tableau pour récupérer les données
  data_SpeciesLambda_2002_dept = matrix(0, noSpecies, FinalYear - REF_YEAR + 
                                          1)
  SpeciesLambda = matrix(0, noSpecies, FinalYear - REF_YEAR + 
                           1)
  PopPredict = as.data.frame(matrix(ncol = 5+NumberYear+NumberYear)) #Sur 35ans (x2 pour les SE) ET 5 col pour infos suplémentaires
  colnames(PopPredict) = c("binomial", "id", "Model", "Model_valide", "Smooth_para", 
                           seq(InitialYear,FinalYear, by = 1), paste(seq(InitialYear,FinalYear, by = 1), "_se", sep = ""))
  
  #variable pour récupérer des infos
  nb_pop_year_lambda = rep(0, NumberYear)
  nb_sp_year_dtemp = rep(0,  FinalYear - REF_YEAR +1)
  compteur = 0
  model_used = c()
  model_valid_used = c()
  
  cat(sprintf("Number of species: %s (in %s populations)\n", 
              noSpecies, noPop))
  for(I in sNames) {
    
    cat(".")
    Index = 1
    if (length(which(objects() == "sIndex")) != 0) {
      rm(sIndex)
    }
    SP = toString(sNames[asso_SPNames_Number%>%
                           filter(binomial == I)%>%
                           pull(number)])
    sIndex = which(Species == SP)
    SpeciesIndex = asso_SPNames_Number%>%
      filter(binomial == I)%>% 
      pull(number)
    
    PopID = unique(ID[sIndex, 1])
    
    if (length(which(objects() == "PopLambda")) != 0) {
      rm(PopLambda)
    }
    PopIDSize = length(PopID)
    PopLambda = matrix(NA, PopIDSize, FinalYear - REF_YEAR + 
                         1)
    JIndex = 1
    
    
    ### Enlever les zéros pour une pop
    
    #choisir la population J de l'espèce I
    for (J in 1:PopIDSize) {
      compteur = compteur+1
      IndexPop = which(ID == PopID[J])
      YearPop = Year[IndexPop, 1]
      #cat("Espece : ", SP, "Pop :", PopID[J], "\n")
      # First_year_pop = YearPop[1]
      # Last_year_pop = YearPop[length(YearPop)]
      PopN = Popvalue[IndexPop, 1]
      
      if(length(PopN) > 1){
        
        PopN = remove_zero(PopN)
        
        SortResults = sort(YearPop, index.return = TRUE)
        YearPop = SortResults$x
        TempI = SortResults$ix
        PopN = PopN[TempI]
        
        ### Vide les variables à utiliser
        if (length(which(objects() == "YearPopInt")) != 
            0) {
          rm(YearPopInt)
        }
        if (length(which(objects() == "PopNInt")) != 
            0) {
          rm(PopNInt)
        }
        if (length(which(objects() == "PopNInt_se")) != 
            0) {
          rm(PopNInt_se)
        }
        
        
        
        #Toutes les années entre la première et la dernière valeur
        YearPopInt = YearPop[1]:YearPop[length(YearPop)]
        PopNLog = log(PopN) # Prendre le log des populations
        GAm_Flag = T
        if (var(PopN) == 0) {
          #cat(sprintf("Variance de PopN = %d\n", var(PopN)))
          GAm_Flag = F
        }
        
        SmoothParm = round(length(PopN)/2)
        
        ### GAM 
        # Si le Smoothparam est inférieur à 3 alors pas de GAM
        
        if (SmoothParm >= 3 & GAm_Flag == T) {
          #cat("GAM_MODEL\n")
          
          res_fit_gam_model = fit_gam_model(SmoothParm, PopNLog, YearPop)
          
          
          if(!is.null(res_fit_gam_model)){
            PopNInt_se = res_fit_gam_model$PopNInt_se
            PopNInt = res_fit_gam_model$PopNInt
            model_used = c("GAM")
            model_valid_used = c("GAM")
            PopPredict = bind_rows(PopPredict, c("binomial" = SP, "id"= PopID[J], 
                                                 "Model" = model_used, "Model_valide" = model_valid_used,"Smooth_para" = SmoothParm,
                                                 setNames(c(PopNInt),YearPopInt),
                                                 setNames(c(PopNInt_se),
                                                          paste(seq(min(YearPopInt),max(YearPopInt), by = 1), "_se", sep = ""))))
          }
        }
        
        #LINEAR_MODEL_FLAG = readline(prompt = "Press 'TRUE' to LINEAR_MODEL, 'F' to go to CHAIN_MODEL")
        
        # if(LINEAR_MODEL_FLAG == TRUE) {### Sinon pas de GAM
        #   #cat("LINEAR_MODEL\n")
        #   res_fit_linear_model = fit_linear_model(YearPop, PopNLog)
        #   PopNInt_lm = res_fit_linear_model$PopNInt
        #   PopNInt_lm_se = res_fit_linear_model$PopNInt_se
        #   model_used = c("Linear")
        #   PopPredict = bind_rows(PopPredict, c("binomial" = SP, "id"= PopID[J], 
        #                                        "Model" = model_used,
        #                                        setNames(c(PopNInt_lm),YearPopInt),
        #                                        setNames(c(PopNInt_lm_se),
        #                                                 paste(seq(min(YearPopInt),max(YearPopInt), by = 1), "_se", sep = ""))))
        # }
        
        #CHAIN_MODEL_FLAG = readline(prompt = "Press 'TRUE' to CHAIN_MODEL, 'F' ")
        
        if(CHAIN_MODEL_FLAG == TRUE) {
          #cat("CHAIN_MODEL\n")
          model_used = "Chain_model"
          
          if("GAM" %in% (PopPredict%>%
                         filter(id == PopID[J])%>%
                         pull(Model_valide))){
            
            model_used = "Chain_model"
            # Apply the default approach (Chain)
            
            PopNInt_chain =  fit_chain_model(YearPopInt, YearPop,PopN)$PopNInt
            PopNInt_chain_se = fit_chain_model(YearPopInt, YearPop,PopN)$PopNInt_se
            PopPredict = bind_rows(PopPredict, c("binomial" = SP, "id"= PopID[J],
                                                 "Model" = model_used,
                                                 setNames(c(PopNInt_chain),YearPopInt),
                                                 setNames(c(PopNInt_chain_se),
                                                          paste(seq(min(YearPopInt),max(YearPopInt), by = 1), "_se", sep = ""))))
            
          }
          
          
          else {
            model_valid_used = "Chain_model"
            model_used = "Chain_model"
            PopNInt =  fit_chain_model(YearPopInt, YearPop,PopN)$PopNInt
            PopNInt_se = fit_chain_model(YearPopInt, YearPop,PopN)$PopNInt_se
            PopPredict = bind_rows(PopPredict, c("binomial" = SP, "id"= PopID[J],
                                                 "Model" = model_used,
                                                 "Model_valide" = model_valid_used,
                                                 setNames(c(PopNInt),YearPopInt),
                                                 setNames(c(PopNInt_se),
                                                          paste(seq(min(YearPopInt),max(YearPopInt), by = 1), "_se", sep = ""))))
            
          }
        }
        
        #Enlever les Zeros des prédictions et mettre en log 
        #Le Living Planet Index (LPI) est souvent calculé sur les moyennes 
        #géométriques de populations standardisées, et ça se fait bien avec des log.
        
        {
          YearPop = InitialYear:FinalYear
          PopN = matrix(0, 1, length(YearPop))
          k = which(PopNInt == 0)
          k1 = which(PopNInt > 0)
          TempVal = 0
          if (length(k) > 0) {
            if (length(k1) > 0) {
              TempVal = mean(PopNInt[k1]) * 0.01
              PopNInt = PopNInt + TempVal
            }
          }
          for (K in InitialYear:FinalYear) {
            k = which(YearPopInt == K)
            if (length(k) > 0) {
              if (PopNInt[k] == 0) {
                PopN[K - InitialYear + 1] = NA
              }
              else {
                #Mettre en Log10 les populations prédites 
                PopN[K - InitialYear + 1] = log10(PopNInt[k])
              }
            }
            else {
              PopN[K - InitialYear + 1] = NA
            }
          }
        }
        
        ###### Calculate the growth rate
        {
          PopLambda = calcul_lambda_pop(PopLambda, JIndex, FinalYear, PopN, InitialYear, REF_YEAR)
          JIndex = JIndex + 1
        }
        
        #################################################### FIN BOUCLE POPULATION
      }
      else{ 
        cat("Less than 2 obs for population :", PopID[J], "\n")}
    }
    # Save the population lamdas to a file:
    PopData = cbind(as.vector(PopID), PopLambda)
    
    
    ####################################### Save the species average lambda values
    {
      res_calcul_lambda_species = calcul_lambda_species(InitialYear = InitialYear,
                                                        FinalYear = FinalYear,
                                                        PopLambda = PopLambda,
                                                        SpeciesIndex = SpeciesIndex,
                                                        REF_YEAR = REF_YEAR,
                                                        LAMBDA_MAX = LAMBDA_MAX,
                                                        LAMBDA_MIN = LAMBDA_MIN)
      data_SpeciesLambda_2002_dept[SpeciesIndex,] = res_calcul_lambda_species$SpeciesLambda[SpeciesIndex,]
      #nb_pop_year_lambda = nb_pop_year_lambda + res_calcul_lambda_species$nb_pop_year_lambda
    }
    ############################################################ FIN BOUCLE ESPECE
  }
  
  
  
  closeAllConnections()
  #Calcul des Dtemp (le taux de croissance total par année)
  results_DTemp = calcul_dtemp(data_SpeciesLambda_2002_dept, CAP_LAMBDAS)
  DTemp_2002_dept = results_DTemp$DTemp
  nb_sp_year_dtemp = nb_sp_year_dtemp + results_DTemp$nb_sp_year_dtemp
  
  #Paramètre pour le LPI
  PLOT_MAX = FinalYear
  REF_YEAR = 2002
  DSize = PLOT_MAX - REF_YEAR + 1
  
  #Calcul de l'indice à partir des Dtemp 
  Ifinal = calcul_index(DTemp_2002_dept, DSize, REF_YEAR, InitialYear)
  valid_index_years = ((!is.na(Ifinal)) & (Ifinal != -99))
  
  
  Ifinal = Ifinal%>%
    as_tibble()%>%
    mutate(LPI_final = V1,
           year = REF_YEAR:PLOT_MAX,
           Nb_sp_year = nb_sp_year_dtemp)%>%
    select(-V1)
  
  #Calcul de l'intervalle de confiance à partir des bootstraps 
  Ifinal_IC = calcul_IC(BOOT_STRAP_SIZE = 1000, DSize, data_SpeciesLambda_2002_dept, 
                        InitialYear, REF_YEAR)$IC
  
  Ifinal_IC = Ifinal_IC%>%
    as_tibble()%>%
    rename_with(~ c("IC_low", "IC_high"))%>%
    mutate(year = REF_YEAR : PLOT_MAX)
  
  
  Ifinal_selection_2002_dept[[as.character(departement)]] = left_join(Ifinal, Ifinal_IC, by = join_by(year))
}


Ifinal_all_dept <- bind_rows(
  .x = Ifinal_selection_2002_dept,
  .id = "dept"
)
```




```{r, fig.width=10, fig.height=6}
ggplot(Ifinal_all_dept,
       aes(x =year)) +
  geom_line(aes(y = LPI_final, color = dept), size = 1.5) +
  geom_ribbon(aes(x = year, ymin = IC_low, ymax = IC_high,fill = dept), alpha = 0.1) +
  geom_hline(yintercept = 1, color = "grey")+
  scale_color_manual(values = color_dept)+
  scale_fill_manual(values = color_dept)+
  scale_y_continuous(limits = c(0.5,2))+
  scale_x_continuous(breaks = seq(2002, 2024, by = 2))+
  facet_wrap(~dept, ncol = 2,
             labeller = labeller(
               dept = c(
                 `21` = paste("Côte d'or (21)", "- Nombre d'espèce :", max(Ifinal_all_dept%>%filter(dept == 21)%>%pull(Nb_sp_year))),
                 `25` =  paste("Doubs (25)", "- Nombre d'espèce :", max(Ifinal_all_dept%>%filter(dept == 25)%>%pull(Nb_sp_year))),
                 `39` =  paste("Jura (39)", "- Nombre d'espèce :", max(Ifinal_all_dept%>%filter(dept == 39)%>%pull(Nb_sp_year))),
                 `58` =  paste("Nièvre (58)", "- Nombre d'espèce :", max(Ifinal_all_dept%>%filter(dept == 58)%>%pull(Nb_sp_year))),
                 `70` =  paste("Haute-Saône (70)", "- Nombre d'espèce :", max(Ifinal_all_dept%>%filter(dept == 70)%>%pull(Nb_sp_year))),
                 `71` =  paste("Saône et Loire (71)", "- Nombre d'espèce :", max(Ifinal_all_dept%>%filter(dept == 71)%>%pull(Nb_sp_year))),
                 `89` =  paste("Yonne (89)", "- Nombre d'espèce :", max(Ifinal_all_dept%>%filter(dept == 89)%>%pull(Nb_sp_year))),
                 `90` =  paste("Territoire de Belfor (90)", "- Nombre d'espèce :", max(Ifinal_all_dept%>%filter(dept == 90)%>%pull(Nb_sp_year)))
               )
             ))+
  labs(x = "Année", y = "IAV (2002 = 1)") +
  theme_bw()+
  theme(legend.position = "none")
```



```{r, fig.width=10, fig.height=6}
ggplot(Ifinal_all_dept,
       aes(x =year)) +
  geom_line(aes(y = LPI_final, color = dept), size = 1.5) +
  geom_ribbon(aes(x = year, ymin = IC_low, ymax = IC_high,fill = dept), alpha = 0.1) +
  geom_hline(yintercept = 1, color = "grey")+
  scale_color_manual(values = color_dept)+
  scale_fill_manual(values = color_dept)+
  scale_y_continuous(limits = c(0.5,2))+
  scale_x_continuous(breaks = seq(2002, 2024, by = 2))+
  labs(x = "Année", y = "IAV (2002 = 1)") +
  theme_bw()+
  theme(legend.position = "right")
```

